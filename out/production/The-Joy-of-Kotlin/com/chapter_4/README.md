
# 재귀  
- 모든 단계를 저장했다가 최종 단계 도착시 계산을 시작  
- 즉 계산의 일부분으로 자신을 호출  
- 불필요한 메모리 사용량 증가  
- 스택오버플로우 유발  
- 작성이나 가독성에서는 재귀가 더 낫다.  
  
# 공재귀  
- 각 단계를 즉시 계산한다.  
- 자신을 불러도 계산의 일부로 부르는 것이 아니다.  
- 공재귀는 루프로 변환할 수 있다 !!  
- 메모리를 아끼고 스택오버플로우를 방지하 수 있다.  
- 재귀를 공재귀로 바꿔서 프로그래밍하자.  
  
#메모화
- 아   
  
# 기타  
- 재귀 함수 값의 경우 tailrec 이 안된다. fun으로 만들고 함수 참조를 사용한다.  
- 함수 값을 재귀함수로 쓸 때 정의가 완료되지 않으면 쓸 수 없다.  
- lateinit var ~ init이나 val f: ~ by lazy {}를 쓴다.  
- 힘수 내부에 로컬함수 정의(helper)시 이름은 함수명_, go나 process로 통일(관례)  
- 재귀와 공재귀는 dual 관계다. 항상 하나는 다른 하나로 변환될 수 있다.  
- companion obect의 function을 프로퍼티에 할당하면 그때마다 객체가 생긴다?
  
# Note  
- fold :   list의 모든 원소를 前값을 이용, 함수 f를 끝까지 적용시킨 후 반환
리스트에서 단일원소로 (단일 원소가 리스트일 수도 있다.)
- map :   fold의 반환을 List\<U>로 구체화한 버전
- unfold : seed로 부터 조건(p) 맞을 때 까지 탐색(f)한 결과를 리스트로 반환
 단일원소에서 리스트로  
- iterate : unfold의 조건(p)를 횟수로 한 버전
- Memoizer.memoize : 적용 함수에 따라 결과를 저장해놓음.